# 开发日志：标签云地图交互增强功能

本文档汇总了近期开发过程中新增的需求、功能实现细节、所使用的技术方案以及遇到的问题与解决方案。

## 1. 新增需求汇总

在原有地图标签云应用的基础上，主要增加了以下交互增强和布局优化需求：

1.  **双向高亮交互 (Bi-directional Highlighting)**：
    *   地图 POI -> 标签：悬停在地图红点上时，右侧标签云对应文字高亮。
    *   标签 -> 地图 POI：悬停在右侧标签上时，左侧地图对应红点高亮（放大、变色）。
2.  **点击定位 (Click to Locate)**：
    *   点击右侧标签，地图自动平滑飞向该 POI 位置并缩放。
3.  **视野实时过滤 (Viewport Filtering)**：
    *   提供开关控制。
    *   开启时，标签云只显示当前地图视野范围内的数据。
    *   地图拖动/缩放时实时更新数据。
4.  **绘制工具状态管理修复**：
    *   解决“停止绘制”按钮点击无效的问题。
    *   解决“初始化”后绘制工具未正确关闭的问题。
5.  **UI/UX 布局优化**：
    *   顶部工具栏布局调整：左右分栏，对齐地图与标签云面板。
    *   控件样式调整：下拉框加宽，按钮对齐。
    *   实时过滤控件移动至地图悬浮层。
    *   解决浏览器顶部黑边及下拉菜单遮挡问题。
6.  **热力图分析功能 (Heatmap Analysis)**：
    *   新增热力图开关，支持对多边形筛选区域内的 POI 进行热力可视化。
    *   实现基于缩放级别的动态热力参数调整（缩放聚合/分散）。
    *   高性能渲染，支持 5000+ 数据点平滑交互。
7.  **绘制模式扩展 (Drawing Modes)**：
    *   将“开始绘制”按钮升级为选择器，支持“绘制多边形”和“绘制圆形”两种模式。
    *   新增圆形绘制交互，支持通过圆心和半径定义筛选范围。
    *   实现圆形范围内的 POI 筛选（点与圆心距离计算）与高亮。

---

## 2. 功能实现详解

### 2.1 双向高亮交互

**技术栈**：Vue 3 (Composition API), OpenLayers, D3.js

**实现逻辑**：

1.  **状态共享**：在 `App.vue` 中定义响应式状态 `hoveredFeatureId`，用于在 `MapContainer` 和 `TagCloud` 组件间共享当前悬停的 POI 数据。
2.  **Map -> TagCloud**：
    *   **事件监听**：`MapContainer.vue` 中监听 OpenLayers 的 `pointermove` 事件。
    *   **命中检测**：使用 `map.forEachFeatureAtPixel` 检测鼠标下是否有 Feature。
    *   **防抖处理**：使用 50ms 防抖 (`debounce`) 减少高频触发，通过 `emit('hover-feature')` 将数据传递给父组件，更新 `hoveredFeatureId`。
    *   **响应更新**：`TagCloud.vue` 监听 `hoveredFeatureId` 变化，使用 D3 选择器 (`d3.selectAll`) 动态修改对应标签的 `fill` (颜色) 和 `font-weight` (粗细)。
3.  **TagCloud -> Map**：
    *   **事件监听**：`TagCloud.vue` 中为 D3 生成的 `text` 元素绑定 `mouseover/mouseout` 事件，触发 `emit` 更新 `hoveredFeatureId`。
    *   **图层渲染**：`MapContainer.vue` 新增一个独立的 `VectorLayer` (`hoverLayer`)，专门用于渲染高亮状态的点。
    *   **样式变换**：当 `hoveredFeatureId` 变化时，从缓存 (`rawToOlMap`) 中获取对应的 OpenLayers Feature，克隆并添加到 `hoverLayer`，应用放大 (radius: 9) 和橙色填充样式。

### 2.2 点击定位 (FlyTo)

**技术栈**：OpenLayers (View.animate)

**实现逻辑**：

1.  **事件触发**：`TagCloud.vue` 中为标签绑定 `click` 事件，触发 `locate-feature`。
2.  **动画执行**：`MapContainer.vue` 接收事件，调用 `map.getView().animate()` 方法。
    *   **参数**：`center` (目标坐标), `zoom` (缩放级别 17), `duration` (1000ms)。
    *   **坐标转换**：确保使用的坐标系与地图视图一致 (GCJ-02/Web Mercator)。

### 2.3 视野实时过滤

**技术栈**：OpenLayers (Extent API), Vue Computed Properties, Lodash (Throttle 思想)

**实现逻辑**：

1.  **边界获取**：`MapContainer.vue` 监听 `moveend` 事件，通过 `map.getView().calculateExtent()` 获取当前视图的地理边界（经纬度）。
2.  **节流优化**：使用自定义 `throttle` 函数（500ms 间隔）限制 `map-move-end` 事件的发送频率，防止计算过载。
3.  **数据过滤**：
    *   `App.vue` 中接收边界数据 `mapBounds`。
    *   使用 `computed` 属性 `filteredTagData`，根据开关状态 `filterEnabled` 决定返回全量数据还是过滤后的数据。
    *   过滤逻辑：`poi.lon >= minLon && poi.lon <= maxLon ...`。

### 2.4 绘制工具修复

**技术栈**：OpenLayers (Interaction API)

**实现逻辑**：

1.  **问题分析**：原代码仅移除 `drawInteraction` 变量引用的交互对象。如果变量引用丢失或被覆盖，地图内部的交互对象仍然存在，导致“无法停止”。
2.  **强健修复**：在 `closePolygonDraw` 方法中，改为**遍历地图当前所有交互对象** (`map.getInteractions()`)。
    *   检查每个交互对象是否为 `Draw` 类的实例。
    *   如果是，则强制调用 `map.removeInteraction()` 移除。
3.  **状态同步**：在 `App.vue` 的 `handleReset` 和 `handlePolygonCompleted` 中，显式调用 `controlPanelRef` 的方法重置按钮文字状态。

### 2.5 布局优化

**技术栈**：CSS Flexbox, Element Plus

**实现逻辑**：

1.  **全局样式**：在 `style.css` 中设置 `body { margin: 0; padding: 0; box-sizing: border-box; }` 消除黑边。
2.  **层级管理**：给顶部栏 `.top-controls` 设置 `z-index: 2000` 和 `position: relative`，解决下拉菜单被地图遮挡问题。
3.  **悬浮控件**：将实时过滤开关封装在 `.map-filter-control` 中，使用 `position: absolute; top: 10px; right: 10px;` 悬浮于地图右上角。
4.  **分栏对齐**：使用 Flexbox 的 `justify-content: space-between` (或左右两个 div 分别 flex-start/flex-end) 实现下拉框靠左、按钮靠右的布局。

### 2.6 热力图分析功能

**技术栈**：OpenLayers (Heatmap Layer), WebGL

**实现逻辑**：

1.  **图层集成**：
    *   在 `MapContainer.vue` 中引入 `ol/layer/Heatmap`。
    *   图层 `zIndex` 设为 90，位于高亮图层下方、多边形图层上方。
2.  **数据同步**：
    *   监听 `polygon-completed` 流程。当多边形筛选出 POI 数据后，自动清空并重新填充热力图的数据源 (`heatmapSource`)。
    *   数据源共享：复用筛选出的 `insideRaw` 数据，将其转换为 OpenLayers Feature 注入热力图。
3.  **动态视觉效果 (Dynamic Style)**：
    *   监听地图视图的 `change:resolution` 事件。
    *   **算法**：根据当前缩放级别 (`zoom`) 线性插值计算热力图的 `radius` (半径) 和 `blur` (模糊度)。
        *   **低缩放 (Far, zoom < 10)**：Radius ~30px, Blur ~25px —— 呈现宏观聚集态势。
        *   **高缩放 (Close, zoom > 18)**：Radius ~5px, Blur ~5px —— 呈现微观离散分布。
    *   效果：用户缩放地图时，热力图平滑过渡，避免了固定半径导致的“糊成一片”或“过于稀疏”的问题。
4.  **UI 控制**：
    *   在地图悬浮控件区新增“热力图”开关 (`el-switch`)。
    *   利用 Vue 的 `watch` 监听开关状态，实时控制图层的 `visible` 属性。

### 2.7 绘制模式扩展

**技术栈**：Vue 3, OpenLayers (Draw Interaction, Circle Geometry)

**实现逻辑**：

1.  **UI 升级**：
    *   改造 `ControlPanel` 组件，将单一按钮替换为 `el-select` 下拉框。
    *   提供 `Polygon` (多边形) 和 `Circle` (圆形) 两个选项。
    *   选择对应模式后，触发 `toggle-draw` 事件，携带模式参数 `{ active: true, mode: 'Circle'/'Polygon' }`。
2.  **交互实现**：
    *   在 `MapContainer.vue` 中，根据接收到的模式参数初始化 `ol.interaction.Draw`。
    *   若模式为 `Circle`，设置 `type: 'Circle'`。
3.  **空间筛选**：
    *   **多边形**：使用射线法 (`pointInPolygonPixel`) 判断点是否在多边形内。
    *   **圆形**：
        *   监听绘制结束事件 (`drawend`) 获取圆形几何体 (`Circle Geometry`)。
        *   获取圆心坐标和半径（地图单位，EPSG:3857 下为米）。
        *   遍历所有 POI，计算其与圆心的欧氏距离。
        *   若 `distance <= radius`，则判定为选中。
4.  **数据同步**：
    *   选中的 POI 数据同步更新至高亮图层和热力图数据源。
    *   向父组件触发 `polygon-completed` 事件（对于圆形，`polygon` 边界字段传 `null`，仅传递筛选出的 `selected` 数据和中心点）。

---

## 3. 遇到的问题与解决办法

### 问题 1：`Uncaught TypeError: rawToOlMap.clear is not a function`
*   **现象**：控制台报错，地图无法初始化。
*   **原因**：代码中同时引入了 OpenLayers 的 `Map` 类和使用了 JS 原生的 `Map` 对象。由于命名冲突，`new Map()` 被解析为创建 OpenLayers 地图实例，而 OL 实例没有 `clear()` 方法。
*   **解决**：将 OpenLayers 的引入重命名为 `import OlMap from 'ol/Map'`，保留原生 `Map` 关键字用于创建哈希表。

### 问题 2：停止绘制按钮点击无效
*   **现象**：点击“停止绘制”后，鼠标在地图上点击依然会产生绘制点。
*   **原因**：`drawInteraction` 变量可能在某些重置操作中丢失了对当前活动交互对象的引用，或者存在多个交互实例。
*   **解决**：不再依赖单一变量引用，而是通过 `map.getInteractions()` 获取所有交互并按类型 (`instanceof Draw`) 过滤移除，确保彻底清除。

### 问题 3：下拉菜单被地图遮挡
*   **现象**：Element Plus 的下拉菜单展开后显示在地图图层下方。
*   **原因**：OpenLayers 地图容器通常具有独立的层级上下文，且 Vue 组件样式隔离导致层级计算复杂。
*   **解决**：提升顶部栏 `z-index` 至 2000，并确保其父容器定位上下文正确。
