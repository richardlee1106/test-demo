<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ ‡ç­¾äº‘å¸ƒå±€ç®—æ³•æ€§èƒ½å¯¹æ¯”æµ‹è¯•</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e8e8e8;
            padding: 20px;
        }
        
        .container { max-width: 1300px; margin: 0 auto; }
        
        h1 {
            text-align: center;
            font-size: 2rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle { text-align: center; color: #888; margin-bottom: 20px; font-size: 0.95rem; }
        
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel h2 { font-size: 1.1rem; margin-bottom: 15px; color: #00d4ff; }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }
        
        .config-item label { display: block; font-size: 0.8rem; color: #aaa; margin-bottom: 4px; }
        .config-item .hint { font-size: 0.7rem; color: #666; margin-top: 2px; }
        
        .config-item input, .config-item select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 0.9rem;
        }
        
        .btn-row { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        
        .btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-load { background: linear-gradient(135deg, #00ff88, #00cc6a); color: #000; }
        .btn-run { background: linear-gradient(135deg, #00d4ff, #0095ff); color: #fff; }
        .btn-export { background: linear-gradient(135deg, #7b2cbf, #9d4edd); color: #fff; }
        .btn:hover:not(:disabled) { transform: translateY(-2px); }
        
        .progress-bar { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-bottom: 8px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #00d4ff, #7b2cbf); width: 0%; transition: width 0.3s; }
        .progress-text { text-align: center; color: #888; font-size: 0.85rem; }
        
        .table-wrapper { overflow-x: auto; }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            white-space: nowrap;
        }
        
        .comparison-table th {
            padding: 10px 8px;
            text-align: center;
            background: rgba(0, 212, 255, 0.1);
            color: #aaa;
            font-weight: 600;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        
        .comparison-table th.header-config { background: rgba(255,255,255,0.05); color: #888; }
        .comparison-table th.header-basic { color: #00d4ff; }
        .comparison-table th.header-spiral { color: #b388ff; }
        .comparison-table th.header-compare { color: #ffd93d; }
        
        .comparison-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        
        .comparison-table tr:hover { background: rgba(255,255,255,0.02); }
        
        .comparison-table .cell-config { color: #888; font-weight: 600; }
        .comparison-table .cell-basic { color: #00d4ff; }
        .comparison-table .cell-spiral { color: #b388ff; }
        
        .comparison-table .winner-row-basic { background: linear-gradient(90deg, rgba(0, 212, 255, 0.08), transparent); }
        .comparison-table .winner-row-spiral { background: linear-gradient(270deg, rgba(179, 136, 255, 0.08), transparent); }
        
        .comparison-table .better { font-weight: 700; }
        .comparison-table .diff-faster { color: #00ff88; font-weight: 600; }
        .comparison-table .diff-slower { color: #ff6b6b; }
        
        .winner-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .winner-badge.basic { background: rgba(0, 212, 255, 0.2); color: #00d4ff; }
        .winner-badge.spiral { background: rgba(179, 136, 255, 0.2); color: #b388ff; }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        
        .stat-card .value { font-size: 1.4rem; font-weight: 700; }
        .stat-card .label { font-size: 0.75rem; color: #888; margin-top: 4px; }
        .stat-card.basic .value { color: #00d4ff; }
        .stat-card.spiral .value { color: #b388ff; }
        
        .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px; }
        .chart-box { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; }
        .chart-box h3 { font-size: 0.9rem; color: #aaa; margin-bottom: 8px; }
        .chart-box canvas { max-height: 250px; }
        
        .conclusion-box {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border-left: 4px solid #ffd93d;
        }
        
        .conclusion-box h3 { color: #ffd93d; margin-bottom: 12px; font-size: 1rem; }
        .conclusion-box ul { margin-left: 20px; line-height: 1.7; }
        .conclusion-box li { color: #ccc; margin-bottom: 6px; font-size: 0.9rem; }
        .conclusion-box strong { color: #fff; }
        
        .log-box {
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            padding: 12px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
        }
        
        .log-info { color: #00d4ff; }
        .log-success { color: #00ff88; }
        .log-warning { color: #ffd93d; }
        
        .spinner {
            display: inline-block;
            width: 14px; height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        @media (max-width: 768px) { .charts-row { grid-template-columns: 1fr; } }
        
        .metric-info {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 8px;
            font-size: 0.8rem;
        }
        
        .metric-info div { color: #aaa; }
        .metric-info strong { color: #00d4ff; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ æ ‡ç­¾äº‘å¸ƒå±€ç®—æ³•æ€§èƒ½å¯¹æ¯”</h1>
        <p class="subtitle">Basic (åŠ¨æ€é‡å¿ƒ + RBush) vs Spiral (é˜¿åŸºç±³å¾·èºæ—‹)</p>
        
        <div class="panel">
            <h2>âš™ï¸ æµ‹è¯•é…ç½®</h2>
            <div class="config-grid">
                <div class="config-item">
                    <label>ğŸ“ æ•°æ®æº</label>
                    <select id="dataSource"><option value="">è¯·å…ˆåŠ è½½æ•°æ®</option></select>
                </div>
                <div class="config-item">
                    <label>ğŸ”¢ æ ‡ç­¾æ•°é‡</label>
                    <input type="text" id="tagCounts" value="50, 100, 200, 500, 1000">
                    <div class="hint">é€—å·åˆ†éš”</div>
                </div>
                <div class="config-item">
                    <label>ğŸ”„ é‡å¤æ¬¡æ•°</label>
                    <input type="number" id="repeatCount" value="3" min="1" max="5">
                </div>
                <div class="config-item">
                    <label>ğŸ“ ç”»å¸ƒå°ºå¯¸</label>
                    <input type="text" id="canvasSize" value="800, 600">
                </div>
                <div class="config-item">
                    <label>ğŸ”µ æ­¥é•¿ (spiralStep)</label>
                    <input type="text" id="spiralSteps" value="3, 5, 8">
                    <div class="hint">é€—å·åˆ†éš”</div>
                </div>
                <div class="config-item">
                    <label>ğŸ”µ é—´è· (padding)</label>
                    <input type="text" id="paddings" value="2, 5, 10">
                    <div class="hint">é€—å·åˆ†éš”</div>
                </div>
            </div>
            <div class="btn-row">
                <button id="loadBtn" class="btn btn-load" onclick="loadAllData()">ğŸ“‚ åŠ è½½æ•°æ®</button>
                <button id="runBtn" class="btn btn-run" onclick="runBenchmark()" disabled>â–¶ å¼€å§‹æµ‹è¯•</button>
                <button class="btn btn-export" onclick="exportReport()">ğŸ“„ å¯¼å‡ºæŠ¥å‘Š</button>
            </div>
        </div>
        
        <div class="panel" id="progressPanel" style="display: none;">
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            <p class="progress-text" id="progressText">å‡†å¤‡ä¸­...</p>
        </div>
        
        <div class="panel">
            <h2>ğŸ“‹ æµ‹è¯•æ—¥å¿—</h2>
            <div class="log-box" id="logBox"><div class="log-info">ç­‰å¾…åŠ è½½æ•°æ®...</div></div>
        </div>
        
        <div class="panel" id="resultsPanel" style="display: none;">
            <h2>ğŸ“Š å¯¹æ¯”ç»“æœ</h2>
            
            <div class="metric-info">
                <div><strong>è€—æ—¶:</strong> å¸ƒå±€è®¡ç®—æ€»æ—¶é—´ (ms)ï¼Œåæ˜ ç®—æ³•æ€§èƒ½</div>
                <div><strong>ç´§å‡‘åº¦:</strong> æ ‡ç­¾æ€»é¢ç§¯ / å®é™…å¤–æ¥çŸ©å½¢é¢ç§¯ (0-100%)ï¼Œåæ˜ å¸ƒå±€ç´§å‡‘ç¨‹åº¦</div>
                <div><strong>å¹³å‡é—´éš™:</strong> æ ‡ç­¾è¾¹ç¼˜é—´çš„å¹³å‡æœ€å°è·ç¦» (px)ï¼Œåæ˜ å¸ƒå±€ç–å¯†åº¦</div>
            </div>
            
            <div class="stats-grid" id="statsGrid"></div>
            
            <div class="table-wrapper">
                <table class="comparison-table" id="comparisonTable">
                    <thead>
                        <tr>
                            <th class="header-config">æ ‡ç­¾æ•°</th>
                            <th class="header-config">æ­¥é•¿</th>
                            <th class="header-config">é—´è·</th>
                            <th class="header-basic">Basic<br>è€—æ—¶</th>
                            <th class="header-spiral">Spiral<br>è€—æ—¶</th>
                            <th class="header-compare">æ—¶é—´å·®</th>
                            <th class="header-basic">Basic<br>ç´§å‡‘åº¦</th>
                            <th class="header-spiral">Spiral<br>ç´§å‡‘åº¦</th>
                            <th class="header-basic">Basic<br>å¹³å‡é—´éš™</th>
                            <th class="header-spiral">Spiral<br>å¹³å‡é—´éš™</th>
                            <th class="header-compare">èƒœå‡º</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>
            
            <div class="charts-row">
                <div class="chart-box">
                    <h3>â±ï¸ è¿è¡Œæ—¶é—´å¯¹æ¯”</h3>
                    <canvas id="timeChart"></canvas>
                </div>
                <div class="chart-box">
                    <h3>ğŸ“ ç´§å‡‘åº¦å¯¹æ¯”</h3>
                    <canvas id="compactnessChart"></canvas>
                </div>
            </div>
            
            <div class="conclusion-box" id="conclusionBox"></div>
        </div>
    </div>
    
    <script type="module">
        import RBush from 'https://cdn.jsdelivr.net/npm/rbush@3.0.1/+esm';
        
        let loadedData = {};
        let allResults = [];
        let timeChart = null;
        let compactnessChart = null;
        
        const DATA_SOURCES = [
            'æ—…æ¸¸æ™¯ç‚¹', 'é¤é¥®ç¾é£Ÿ', 'è´­ç‰©æ¶ˆè´¹', 'ä¼‘é—²å¨±ä¹', 'å…¬å¸ä¼ä¸š',
            'äº¤é€šè®¾æ–½', 'åŒ»ç–—ä¿å¥', 'å•†åŠ¡ä½å®…', 'æ±½è½¦ç›¸å…³', 'ç”Ÿæ´»æœåŠ¡',
            'ç§‘æ•™æ–‡åŒ–', 'è¿åŠ¨å¥èº«', 'é…’åº—ä½å®¿', 'é‡‘èæœºæ„'
        ];
        
        window.loadAllData = loadAllData;
        window.runBenchmark = runBenchmark;
        window.exportReport = exportReport;
        
        function log(msg, type = 'info') {
            const box = document.getElementById('logBox');
            const div = document.createElement('div');
            div.className = `log-${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }
        
        function parseArray(str) {
            return str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
        }
        
        async function loadAllData() {
            const btn = document.getElementById('loadBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>åŠ è½½ä¸­...';
            
            document.getElementById('logBox').innerHTML = '';
            log('å¼€å§‹åŠ è½½ POI æ•°æ®...', 'info');
            
            for (const name of DATA_SOURCES) {
                try {
                    const res = await fetch(`/data/${name}.geojson`);
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    const json = await res.json();
                    loadedData[name] = (json.features || []).map(f => ({
                        name: f.properties?.åç§° || 'æœªå‘½å',
                        lon: f.geometry?.coordinates?.[0],
                        lat: f.geometry?.coordinates?.[1]
                    })).filter(t => t.name && t.lon);
                    log(`âœ“ ${name}: ${loadedData[name].length} æ¡`, 'success');
                } catch (e) {
                    log(`âœ— ${name}: ${e.message}`, 'warning');
                }
            }
            
            const select = document.getElementById('dataSource');
            select.innerHTML = '<option value="all">å…¨éƒ¨åˆå¹¶</option>' +
                Object.entries(loadedData)
                    .filter(([_, d]) => d.length > 0)
                    .map(([n, d]) => `<option value="${n}">${n} (${d.length})</option>`)
                    .join('');
            
            log(`âœ… åŠ è½½å®Œæˆï¼`, 'success');
            btn.disabled = false;
            btn.innerHTML = 'ğŸ“‚ åŠ è½½æ•°æ®';
            document.getElementById('runBtn').disabled = false;
        }
        
        // ========== ä¿®æ­£çš„ç´§å‡‘åº¦è®¡ç®— ==========
        // ç´§å‡‘åº¦ (Packing Density) = æ ‡ç­¾æ€»é¢ç§¯ / å®é™…å¤–æ¥çŸ©å½¢é¢ç§¯
        // è¿™æ˜¯ä¸€ä¸ªæ ‡å‡†çš„å¡«å……ç‡æŒ‡æ ‡ï¼ŒèŒƒå›´ 0-100%
        function evaluateLayout(placedTags) {
            if (!placedTags || placedTags.length < 2) {
                return { compactness: 0, avgGap: 0 };
            }
            
            let totalTagArea = 0;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            
            for (const tag of placedTags) {
                totalTagArea += tag.width * tag.height;
                minX = Math.min(minX, tag.x - tag.width / 2);
                maxX = Math.max(maxX, tag.x + tag.width / 2);
                minY = Math.min(minY, tag.y - tag.height / 2);
                maxY = Math.max(maxY, tag.y + tag.height / 2);
            }
            
            const boundingArea = (maxX - minX) * (maxY - minY);
            const compactness = boundingArea > 0 ? (totalTagArea / boundingArea) * 100 : 0;
            
            // è®¡ç®—å¹³å‡æœ€å°é—´éš™
            let totalMinGap = 0;
            for (let i = 0; i < placedTags.length; i++) {
                const t1 = placedTags[i];
                let minGap = Infinity;
                for (let j = 0; j < placedTags.length; j++) {
                    if (i === j) continue;
                    const t2 = placedTags[j];
                    const dx = Math.max(0, Math.abs(t1.x - t2.x) - (t1.width + t2.width) / 2);
                    const dy = Math.max(0, Math.abs(t1.y - t2.y) - (t1.height + t2.height) / 2);
                    const gap = Math.sqrt(dx * dx + dy * dy);
                    if (gap < minGap) minGap = gap;
                }
                if (minGap < Infinity) totalMinGap += minGap;
            }
            
            return { compactness: Math.min(compactness, 100), avgGap: totalMinGap / placedTags.length };
        }
        
        // ========== Basic ç®—æ³• ==========
        function runBasicLayout(tags, width, height, cfg) {
            const start = performance.now();
            if (!tags?.length) return { time: 0, placed: 0, total: 0, quality: { compactness: 0, avgGap: 0 } };
            
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');
            
            const processed = tags.map((t, i) => {
                const ratio = 1 - Math.pow(i / Math.max(1, tags.length - 1), 0.5);
                const fs = 18 + ratio * 4;
                ctx.font = `${fs}px sans-serif`;
                const w = Math.ceil(ctx.measureText(t.name).width);
                return { ...t, fontSize: fs, width: w, height: Math.ceil(fs * 1.2), x: 0, y: 0 };
            });
            
            processed.sort((a, b) => b.fontSize - a.fontSize);
            
            const tree = new RBush();
            const placed = [];
            let cx = width / 2, cy = height / 2;
            
            for (let i = 0; i < processed.length; i++) {
                const tag = processed[i];
                let found = false;
                
                // ç»Ÿä¸€é—´éš™ç¼©å‡ç­–ç•¥
                const phases = [1.0, 0.8, 0.6, 0.4, 0.2];
                for (const factor of phases) {
                    if (found) break;
                    const currentPadding = cfg.padding * factor;
                    const sx = i === 0 ? width / 2 : cx;
                    const sy = i === 0 ? height / 2 : cy;
                    let theta = 0;
                    const maxR = Math.sqrt(width * width + height * height) * 2;
                    
                    while (!found && theta < 800) {
                        const r = cfg.spiralStep * theta;
                        if (r > maxR) break;
                        const x = sx + r * Math.cos(theta);
                        const y = sy + r * Math.sin(theta);
                        const box = {
                            minX: x - tag.width / 2 - currentPadding,
                            minY: y - tag.height / 2 - currentPadding,
                            maxX: x + tag.width / 2 + currentPadding,
                            maxY: y + tag.height / 2 + currentPadding
                        };
                        if (!tree.collides(box)) {
                            tag.x = x; tag.y = y;
                            placed.push(tag);
                            tree.insert(box);
                            const n = placed.length - 1;
                            cx = n === 0 ? x : (cx * n + x) / (n + 1);
                            cy = n === 0 ? y : (cy * n + y) / (n + 1);
                            found = true;
                        }
                        theta += 0.1;
                    }
                }
            }
            const quality = evaluateLayout(placed);
            return { time: performance.now() - start, placed: placed.length, total: processed.length, quality };
        }
        
        // ========== Spiral ç®—æ³• ==========
        function runSpiralLayout(tags, width, height, cfg) {
            const start = performance.now();
            if (!tags?.length) return { time: 0, placed: 0, total: 0, quality: { compactness: 0, avgGap: 0 } };
            
            const canvas = new OffscreenCanvas(width, height);
            const ctx = canvas.getContext('2d');
            const centerX = width / 2, centerY = height / 2;
            
            const processed = tags.map((t, i) => {
                const ratio = 1 - Math.pow(i / Math.max(1, tags.length - 1), 0.5);
                const fs = 18 + ratio * 4;
                ctx.font = `${fs}px sans-serif`;
                const w = Math.ceil(ctx.measureText(t.name).width);
                return { ...t, fontSize: fs, width: w, height: Math.ceil(fs * 1.2), x: 0, y: 0 };
            });
            
            processed.sort((a, b) => b.fontSize - a.fontSize);
            
            const placed = [];
            const maxR = Math.sqrt(width * width + height * height) * 2;
            
            for (const tag of processed) {
                let found = false;
                const phases = [1.0, 0.8, 0.6, 0.4, 0.2];
                
                for (const factor of phases) {
                    if (found) break;
                    const currentPadding = cfg.padding * factor;
                    let theta = 0;
                    
                    while (!found && theta < 800) {
                        const r = cfg.spiralStep * theta;
                        if (r > maxR) break;
                        
                        const x = centerX + r * Math.cos(theta);
                        const y = centerY + r * Math.sin(theta);
                        
                        let collision = false;
                        for (const p of placed) {
                            if (!(x + tag.width / 2 + currentPadding < p.x - p.width / 2 ||
                                  x - tag.width / 2 - currentPadding > p.x + p.width / 2 ||
                                  y + tag.height / 2 + currentPadding < p.y - p.height / 2 ||
                                  y - tag.height / 2 - currentPadding > p.y + p.height / 2)) {
                                collision = true;
                                break;
                            }
                        }
                        
                        if (!collision) {
                            tag.x = x; tag.y = y;
                            placed.push(tag);
                            found = true;
                        }
                        theta += 0.1;
                    }
                }
            }
            
            const quality = evaluateLayout(placed);
            return { time: performance.now() - start, placed: placed.length, total: processed.length, quality };
        }
        
        async function runBenchmark() {
            if (!Object.keys(loadedData).length) { alert('è¯·å…ˆåŠ è½½æ•°æ®ï¼'); return; }
            
            const btn = document.getElementById('runBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>æµ‹è¯•ä¸­...';
            
            document.getElementById('logBox').innerHTML = '';
            allResults = [];
            
            const tagCounts = parseArray(document.getElementById('tagCounts').value);
            const spiralSteps = parseArray(document.getElementById('spiralSteps').value);
            const paddings = parseArray(document.getElementById('paddings').value);
            const repeatCount = parseInt(document.getElementById('repeatCount').value) || 3;
            const [width, height] = parseArray(document.getElementById('canvasSize').value);
            
            const source = document.getElementById('dataSource').value;
            let data = source === 'all' ? Object.values(loadedData).flat() : (loadedData[source] || []);
            
            log(`æ•°æ®æº: ${source === 'all' ? 'å…¨éƒ¨' : source} (${data.length} æ¡)`, 'info');
            log(`æ ‡ç­¾æ•°: ${tagCounts.join(', ')}`, 'info');
            log(`æ­¥é•¿: ${spiralSteps.join(', ')} | é—´è·: ${paddings.join(', ')}`, 'info');
            
            document.getElementById('progressPanel').style.display = 'block';
            
            const total = tagCounts.length * spiralSteps.length * paddings.length * 2 * repeatCount;
            let done = 0;
            
            for (const count of tagCounts) {
                const sample = data.slice(0, Math.min(count, data.length));
                const actualCount = sample.length;
                
                for (const step of spiralSteps) {
                    for (const padding of paddings) {
                        const cfg = { spiralStep: step, padding };
                        
                        let basicTimes = [], basicResult = null;
                        for (let r = 0; r < repeatCount; r++) {
                            await new Promise(res => setTimeout(res, 5));
                            basicResult = runBasicLayout(sample, width, height, cfg);
                            basicTimes.push(basicResult.time);
                            done++;
                            document.getElementById('progressFill').style.width = `${(done / total) * 100}%`;
                            document.getElementById('progressText').textContent = `${Math.round(done / total * 100)}%`;
                        }
                        
                        let spiralTimes = [], spiralResult = null;
                        for (let r = 0; r < repeatCount; r++) {
                            await new Promise(res => setTimeout(res, 5));
                            spiralResult = runSpiralLayout(sample, width, height, cfg);
                            spiralTimes.push(spiralResult.time);
                            done++;
                            document.getElementById('progressFill').style.width = `${(done / total) * 100}%`;
                            document.getElementById('progressText').textContent = `${Math.round(done / total * 100)}%`;
                        }
                        
                        const basicAvg = basicTimes.reduce((a, b) => a + b, 0) / basicTimes.length;
                        const spiralAvg = spiralTimes.reduce((a, b) => a + b, 0) / spiralTimes.length;
                        const diff = basicAvg - spiralAvg;
                        const winner = basicAvg < spiralAvg ? 'Basic' : 'Spiral';
                        
                        allResults.push({
                            count: actualCount,
                            step,
                            padding,
                            basicTime: basicAvg,
                            basicCompactness: basicResult.quality.compactness,
                            basicAvgGap: basicResult.quality.avgGap,
                            spiralTime: spiralAvg,
                            spiralCompactness: spiralResult.quality.compactness,
                            spiralAvgGap: spiralResult.quality.avgGap,
                            diff,
                            winner
                        });
                        
                        log(`${actualCount}æ ‡ç­¾ æ­¥é•¿=${step} é—´è·=${padding}: Basic ${basicAvg.toFixed(0)}ms vs Spiral ${spiralAvg.toFixed(0)}ms â†’ ${winner}`, 'success');
                    }
                }
            }
            
            log('âœ… æµ‹è¯•å®Œæˆï¼', 'success');
            displayResults();
            btn.disabled = false;
            btn.innerHTML = 'â–¶ å¼€å§‹æµ‹è¯•';
        }
        
        function displayResults() {
            document.getElementById('resultsPanel').style.display = 'block';
            
            const basicWins = allResults.filter(r => r.winner === 'Basic').length;
            const spiralWins = allResults.length - basicWins;
            const avgBasic = allResults.reduce((a, r) => a + r.basicTime, 0) / allResults.length;
            const avgSpiral = allResults.reduce((a, r) => a + r.spiralTime, 0) / allResults.length;
            const avgBasicCompact = allResults.reduce((a, r) => a + r.basicCompactness, 0) / allResults.length;
            const avgSpiralCompact = allResults.reduce((a, r) => a + r.spiralCompactness, 0) / allResults.length;
            
            document.getElementById('statsGrid').innerHTML = `
                <div class="stat-card basic"><div class="label">Basic èƒœå‡ºæ¬¡æ•°</div><div class="value">${basicWins}</div></div>
                <div class="stat-card spiral"><div class="label">Spiral èƒœå‡ºæ¬¡æ•°</div><div class="value">${spiralWins}</div></div>
                <div class="stat-card basic"><div class="label">Basic å¹³å‡è€—æ—¶</div><div class="value">${avgBasic.toFixed(0)}ms</div></div>
                <div class="stat-card spiral"><div class="label">Spiral å¹³å‡è€—æ—¶</div><div class="value">${avgSpiral.toFixed(0)}ms</div></div>
                <div class="stat-card basic"><div class="label">Basic å¹³å‡ç´§å‡‘åº¦</div><div class="value">${avgBasicCompact.toFixed(1)}%</div></div>
                <div class="stat-card spiral"><div class="label">Spiral å¹³å‡ç´§å‡‘åº¦</div><div class="value">${avgSpiralCompact.toFixed(1)}%</div></div>
            `;
            
            document.getElementById('tableBody').innerHTML = allResults.map(r => {
                const timeBetter = r.basicTime < r.spiralTime ? 'basic' : 'spiral';
                const compactBetter = r.basicCompactness > r.spiralCompactness ? 'basic' : 'spiral';
                const gapBetter = r.basicAvgGap < r.spiralAvgGap ? 'basic' : 'spiral';
                
                return `
                <tr class="${r.winner === 'Basic' ? 'winner-row-basic' : 'winner-row-spiral'}">
                    <td class="cell-config">${r.count}</td>
                    <td class="cell-config">${r.step}</td>
                    <td class="cell-config">${r.padding}</td>
                    <td class="cell-basic ${timeBetter === 'basic' ? 'better' : ''}">${r.basicTime.toFixed(1)}</td>
                    <td class="cell-spiral ${timeBetter === 'spiral' ? 'better' : ''}">${r.spiralTime.toFixed(1)}</td>
                    <td class="${r.diff > 0 ? 'diff-slower' : 'diff-faster'}">${r.diff > 0 ? '+' : ''}${r.diff.toFixed(0)}</td>
                    <td class="cell-basic ${compactBetter === 'basic' ? 'better' : ''}">${r.basicCompactness.toFixed(1)}%</td>
                    <td class="cell-spiral ${compactBetter === 'spiral' ? 'better' : ''}">${r.spiralCompactness.toFixed(1)}%</td>
                    <td class="cell-basic ${gapBetter === 'basic' ? 'better' : ''}">${r.basicAvgGap.toFixed(1)}</td>
                    <td class="cell-spiral ${gapBetter === 'spiral' ? 'better' : ''}">${r.spiralAvgGap.toFixed(1)}</td>
                    <td><span class="winner-badge ${r.winner.toLowerCase()}">${r.winner}</span></td>
                </tr>
            `}).join('');
            
            drawCharts();
            generateConclusion();
        }
        
        function drawCharts() {
            if (timeChart) timeChart.destroy();
            if (compactnessChart) compactnessChart.destroy();
            
            const grouped = {};
            for (const r of allResults) {
                if (!grouped[r.count]) grouped[r.count] = { basic: [], spiral: [], basicC: [], spiralC: [] };
                grouped[r.count].basic.push(r.basicTime);
                grouped[r.count].spiral.push(r.spiralTime);
                grouped[r.count].basicC.push(r.basicCompactness);
                grouped[r.count].spiralC.push(r.spiralCompactness);
            }
            
            const labels = Object.keys(grouped).sort((a, b) => parseInt(a) - parseInt(b));
            const basicTimes = labels.map(k => grouped[k].basic.reduce((a, b) => a + b, 0) / grouped[k].basic.length);
            const spiralTimes = labels.map(k => grouped[k].spiral.reduce((a, b) => a + b, 0) / grouped[k].spiral.length);
            const basicCompact = labels.map(k => grouped[k].basicC.reduce((a, b) => a + b, 0) / grouped[k].basicC.length);
            const spiralCompact = labels.map(k => grouped[k].spiralC.reduce((a, b) => a + b, 0) / grouped[k].spiralC.length);
            
            timeChart = new Chart(document.getElementById('timeChart'), {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        { label: 'Basic', data: basicTimes, backgroundColor: 'rgba(0, 212, 255, 0.7)', borderColor: '#00d4ff', borderWidth: 2 },
                        { label: 'Spiral', data: spiralTimes, backgroundColor: 'rgba(179, 136, 255, 0.7)', borderColor: '#b388ff', borderWidth: 2 }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { labels: { color: '#ccc' } } },
                    scales: {
                        x: { title: { display: true, text: 'æ ‡ç­¾æ•°', color: '#888' }, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { title: { display: true, text: 'ms', color: '#888' }, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
            
            compactnessChart = new Chart(document.getElementById('compactnessChart'), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Basic', data: basicCompact, borderColor: '#00d4ff', backgroundColor: 'rgba(0,212,255,0.1)', fill: true, tension: 0.3 },
                        { label: 'Spiral', data: spiralCompact, borderColor: '#b388ff', backgroundColor: 'rgba(179,136,255,0.1)', fill: true, tension: 0.3 }
                    ]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { labels: { color: '#ccc' } } },
                    scales: {
                        x: { title: { display: true, text: 'æ ‡ç­¾æ•°', color: '#888' }, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { title: { display: true, text: 'ç´§å‡‘åº¦ %', color: '#888' }, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    }
                }
            });
        }
        
        function generateConclusion() {
            const basicWins = allResults.filter(r => r.winner === 'Basic').length;
            const spiralWins = allResults.length - basicWins;
            const avgBasic = allResults.reduce((a, r) => a + r.basicTime, 0) / allResults.length;
            const avgSpiral = allResults.reduce((a, r) => a + r.spiralTime, 0) / allResults.length;
            const avgBasicCompact = allResults.reduce((a, r) => a + r.basicCompactness, 0) / allResults.length;
            const avgSpiralCompact = allResults.reduce((a, r) => a + r.spiralCompactness, 0) / allResults.length;
            const avgBasicGap = allResults.reduce((a, r) => a + r.basicAvgGap, 0) / allResults.length;
            const avgSpiralGap = allResults.reduce((a, r) => a + r.spiralAvgGap, 0) / allResults.length;
            
            document.getElementById('conclusionBox').innerHTML = `
                <h3>ğŸ“Œ æµ‹è¯•ç»“è®º</h3>
                <ul>
                    <li><strong>é€Ÿåº¦:</strong> ${avgBasic < avgSpiral ? 'Basic' : 'Spiral'} æ›´å¿« (Basic ${avgBasic.toFixed(0)}ms vs Spiral ${avgSpiral.toFixed(0)}ms)</li>
                    <li><strong>èƒœè´Ÿ:</strong> Basic ${basicWins} èƒœ, Spiral ${spiralWins} èƒœ</li>
                    <li><strong>ç´§å‡‘åº¦:</strong> ${avgBasicCompact > avgSpiralCompact ? 'Basic' : 'Spiral'} æ›´ç´§å‡‘ (Basic ${avgBasicCompact.toFixed(0)}% vs Spiral ${avgSpiralCompact.toFixed(0)}%)</li>
                    <li><strong>å¹³å‡é—´éš™:</strong> ${avgBasicGap < avgSpiralGap ? 'Basic' : 'Spiral'} é—´éš™æ›´å° (Basic ${avgBasicGap.toFixed(1)}px vs Spiral ${avgSpiralGap.toFixed(1)}px)</li>
                    <li><strong>æ¨è:</strong> å¤§æ•°æ®é‡ (>200) æ¨è Basicï¼›è¿½æ±‚ç´§å‡‘å¯è°ƒå°æ­¥é•¿å’Œé—´è·</li>
                </ul>
            `;
        }
        
        function exportReport() {
            if (!allResults.length) { alert('è¯·å…ˆè¿è¡Œæµ‹è¯•ï¼'); return; }
            
            let md = `# æ ‡ç­¾äº‘å¸ƒå±€ç®—æ³•æ€§èƒ½å¯¹æ¯”æŠ¥å‘Š\n\n`;
            md += `**ç”Ÿæˆæ—¶é—´:** ${new Date().toLocaleString()}\n\n`;
            
            md += `## å¯¹æ¯”ç»“æœ\n\n`;
            md += `| æ ‡ç­¾ | æ­¥é•¿ | é—´è· | Basicè€—æ—¶ | Spiralè€—æ—¶ | æ—¶é—´å·® | Basicç´§å‡‘åº¦ | Spiralç´§å‡‘åº¦ | Basicé—´éš™ | Spiralé—´éš™ | èƒœå‡º |\n`;
            md += `|------|------|------|-----------|------------|--------|-------------|--------------|-----------|------------|------|\n`;
            
            for (const r of allResults) {
                md += `| ${r.count} | ${r.step} | ${r.padding} | ${r.basicTime.toFixed(1)}ms | ${r.spiralTime.toFixed(1)}ms | ${r.diff > 0 ? '+' : ''}${r.diff.toFixed(0)}ms | ${r.basicCompactness.toFixed(1)}% | ${r.spiralCompactness.toFixed(1)}% | ${r.basicAvgGap.toFixed(1)}px | ${r.spiralAvgGap.toFixed(1)}px | ${r.winner} |\n`;
            }
            
            const blob = new Blob([md], { type: 'text/markdown' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `ç®—æ³•å¯¹æ¯”æŠ¥å‘Š_${new Date().toISOString().slice(0, 10)}.md`;
            a.click();
            
            log('ğŸ“„ æŠ¥å‘Šå·²å¯¼å‡ºï¼', 'success');
        }
    </script>
</body>
</html>
