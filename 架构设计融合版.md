# 空间数据架构 × 三阶段推理架构融合方案（供 AIIDE 重构代码使用，示例代码用的是py，但是实际上需要替换为nodejs）

> 说明：本文件面向**代码重构**与**架构落地**场景，目标是将现有的数据架构  
> （PostGIS + Milvus + 图数据库 + LangChain 工具链）  
> 与“三阶段架构（Planner → Executor → Writer）”融合，形成一套**可工程化、低 token、可扩展**的 Spatial RAG / GraphRAG 混合方案。  
>
> 本文可以直接交给 AIIDE 或其他代码重构助手作为实现蓝本。

---

## 1. 目标与整体设计原则

### 1.1 目标

1. **保留现有数据架构**：  
   - PostGIS 作为主空间数据库  
   - Milvus 作为语义向量索引  
   - （可选）图数据库作为关系引擎  
   - LangChain 作为基础编排 / 工具封装

2. **引入三阶段推理架构**：  
   - <strong>Planner（规划器）</strong>：LLM 负责把自然语言问题转成结构化 Query Plan  
   - <strong>Executor（执行器）</strong>：后端基于 PostGIS / Milvus / 图数据库真正执行查询  
   - <strong>Writer（解释器）</strong>：LLM 只看压缩后的 JSON 结果，生成自然语言回答

3. **解决现有痛点**：  
   - 避免把**全量 POI 文本 & 空间信息直接塞进 prompt** 导致 token 爆炸  
   - 提升 LLM **自主性**：让模型自己规划“查什么、怎么查”，而不是靠大量 prompt 模板  
   - 同时保持回答中能出现**真实地名与真实距离**，并能给出**区域画像**（如“区域内以餐饮为主”）

### 1.2 设计原则

- **数据层不推翻，只改调用方式**：PostGIS / Milvus / 图数据库依然按你原有方式存储和索引。
- **LLM 不读大数据，只读“小 JSON”**：  
  - 不再让 LLM 直接读取大量 POI 文档  
  - 空间计算与大规模统计交由数据库完成
- **查询流程统一走“三阶段”**：  
  - 前端与调用方只需调用一个高层 API，由内部完成三阶段编排

---

## 2. 融合后的高层架构

```text
+-----------------------------------------------------------+
|                      应用 / API 层                        |
|     /query  接口：输入自然语言问题，输出最终回答          |
+----------------------+----------------+-------------------+
                       |                |
                       v                v
                [Stage 1] Planner   [Stage 3] Writer
                      \                /
                       \              /
                        v            v
                    [Stage 2] Executor
              (PostGIS + Milvus + GraphDB + 缓存)
```

### 2.1 角色与现有组件的映射

| 角色 / 层次          | 主要职责                                             | 使用到的现有组件                                 |
| -------------------- | ---------------------------------------------------- | ------------------------------------------------ |
| **Planner（LLM）**   | 自然语言 → Query Plan(JSON)，不访问数据              | LangChain + LLM（原本用于 QA 的模型）            |
| **Executor（后端）** | 基于 Plan 调用 PostGIS / Milvus / 图数据库并聚合结果 | PostGIS、Milvus、图数据库、Geocoder、Landmark 表 |
| **Writer（LLM）**    | 基于结果 JSON 生成自然语言回答                       | LangChain + LLM（可与 Planner 复用或不同模型）   |

3. 数据架构保持不变，但职责重构
3.1 现有数据架构（保持）
PostGIS（主库）

存储全部 POI 字段：
id, name, address, category, rating, geom, geohash/h3_index 等
提供空间查询能力：ST_DWithin, ST_Distance, ST_Within, 聚合统计等
Milvus（语义向量库）

通过 ETL/脚本 + LangChain PostgresLoader + DocumentTransformer：
从 PostGIS 读出 POI 字段
生成 description 文本（name + category + address + tags + 评论摘要 等）
生成 embedding，写入 Milvus
用作语义检索与相似度排序
图数据库（可选）

存 POI 与 POI / 地标 / 商圈 / 道路等之间的关系
支持多跳关系查询、路径规划、区域连通性分析
Landmark / Geocoder

地名解析，存储“学校、地铁站、商圈”等锚点
Geocoder 把地名/门牌转成坐标
3.2 职责重构要点
PostGIS：
继续作为“主表”，负责空间查询 + 结构化过滤 + 统计聚合；
Milvus：
仅在 PostGIS 已筛选的候选集上做语义精排，而不是对全库乱搜；
图数据库：
当 Query Plan 标记 need_graph_reasoning=true 时，才进入图推理；
LangChain：
原有 RetrievalQA 链不再用于“直接读文档给 LLM”，而被拆分为三个逻辑：
PlannerChain（意图规划）
Executor（调用数据库的普通 Python/后端代码）
WriterChain（结果解释）
4. 三阶段执行流的详细设计
  4.1 阶段一：Planner（查询规划器）
  目标：
  从用户自然语言中抽取结构化查询条件，不访问数据库，只返回 Query Plan JSON。

  #### 4.1.1 Query Plan 结构定义

#### 4.1.2 Planner Prompt（System）

你是一个“空间查询规划器”，职责是把用户的问题转换为结构化的查询计划（Query Plan）。

要求：
1. 分析用户问题中的：
   - 锚点信息（地名、地标、门，如“武汉理工大学南门”）
   - 距离条件（半径/步行时间等，统一转成半径米）
   - 类别（如咖啡馆、蛋糕店、餐饮、教育等）
   - 评分/价格等数值过滤条件
   - 语义偏好（如“环境安静”、“适合学习”、“人少”）
   - 是否需要区域整体画像（如“这附近以什么业态为主？”）
   - 是否涉及路线、连通性、多地标等复杂关系（决定是否开启图推理）
2. 严格按照给定的 QueryPlan JSON 结构输出，不要输出任何额外文本。

注意：
- 如果半径在问题中未给出，但上下文暗示“附近”，默认 1000 米；
- 如果用户问题过于模糊（比如缺城市和地标），输出一个 QueryPlan，
  其中 anchor.type="unknown"，并设置 need_global_context=false，
  由上层逻辑决定是否发起澄清。

#### 4.1.3 PlannerChain 实现（LangChain 示意，此处可以用langgraph）

### 4.2 阶段二：Executor（执行器）

**目标**：
根据 Query Plan 调用 PostGIS / Milvus / 图数据库，完成**全部重活**：空间过滤、数值过滤、语义精排、统计聚合、关系推理。
最终返回一个**紧凑的 JSON 结果**，供 Writer 使用。

#### 4.2.1 核心执行逻辑（路由）

PYTHON复制

```
def execute_query(plan: QueryPlan) -> Dict[str, Any]:    """    统一执行入口，根据 plan 决定走哪个执行路径。    返回结构化 JSON（供 Writer 使用）。    """    if plan.need_graph_reasoning:        return exec_graph_mode(plan)    elif plan.need_global_context:        return exec_global_context_mode(plan)    else:        return exec_basic_mode(plan)
```

#### 4.2.2 基础模式：附近找店 / 简单过滤（80% 场景）

PYTHON复制

def exec_basic_mode(plan: QueryPlan) -> Dict[str, Any]:
    # 1. 锚点解析（Coordinator：GeoCoder + Landmark 表）
​    anchor_point = resolve_anchor(plan.anchor)

    # 2. PostGIS：空间 + 类别 + 评分 过滤，控制候选量（如<=200）
​    candidate_pois = query_pois_by_radius(
​        anchor_point=anchor_point,
​        radius_m=plan.radius_m,
​        categories=plan.categories,
​        min_rating=plan.rating_range[0],
​        max_candidates=200
​    )

​    candidate_ids = [p["id"] for p in candidate_pois]

    # 3. Milvus：在候选集中按语义偏好排序（若无语义偏好可跳过）
​    if plan.semantic_query.strip():
​        ranked_pois = rank_by_semantic(plan.semantic_query, candidate_ids, plan.max_results)
​    else:
​        ranked_pois = candidate_pois[:plan.max_results]

    # 4. 结果压缩（只留下必要字段供 Writer 使用）
​    compressed_pois = [
​        {
​            "id": p["id"],
​            "name": p["name"],
​            "category": p["category"],
​            "rating": p["rating"],
​            "distance_m": p["distance_m"],
​            "anchor_name": plan.anchor.name or "",
​            "tags": p.get("tags", [])
​        }
​        for p in ranked_pois
​    ]

​    return {
​        "mode": "basic",
​        "anchor": plan.anchor.dict(),
​        "pois": compressed_pois,
​        "global_context": None
​    }

> 注意：`query_pois_by_radius`、`rank_by_semantic` 等函数在后面给出 SQL / 伪代码示例。

#### 4.2.3 区域画像模式：需要“这片区域以什么为主”等总结

PYTHON复制

def exec_global_context_mode(plan: QueryPlan) -> Dict[str, Any]:
    anchor_point = resolve_anchor(plan.anchor)
    # 1. 根据锚点和半径构造区域（圆或多边形），也可以用预定义的行政区/商圈
​    area_polygon = build_area_polygon(anchor_point, plan.radius_m)

    # 2. 类别统计（SQL 聚合）
​    category_stats = get_category_stats(area_polygon)

    # 3. 提取代表性地标（学校 / 地铁站 / 商圈）
​    landmarks = get_representative_landmarks(area_polygon)

    # 4. 结合语义偏好，从区域内选 TopK 作为样例 POI
​    all_ids = get_poi_ids_in_polygon(area_polygon, plan.categories)
​    if plan.semantic_query.strip():
​        sample_pois = rank_by_semantic(plan.semantic_query, all_ids, min(plan.max_results, 10))
​    else:
​        sample_pois = get_top_pois_by_rating(all_ids, limit=min(plan.max_results, 10))

​    return {
​        "mode": "global_context",
​        "anchor": plan.anchor.dict(),
​        "pois": [
​            {
​                "id": p["id"],
​                "name": p["name"],
​                "category": p["category"],
​                "rating": p["rating"],
​                "distance_m": p["distance_m"],
​                "anchor_name": plan.anchor.name or "",
​                "tags": p.get("tags", [])
​            }
​            for p in sample_pois
​        ],
​        "global_context": {
​            "category_stats": category_stats,
​            "landmarks": landmarks
​        }
​    }

#### 4.2.4 图模式：路径 / 连通性 / 多地标推理

PYTHON复制

def exec_graph_mode(plan: QueryPlan) -> Dict[str, Any]:
    anchor_point = resolve_anchor(plan.anchor)

    # 1. 调图库（例如 Neo4j）做关系/路径查询
​    graph_substructure = query_graph_by_plan(plan)

    # 2. 用 PostGIS 校验空间约束（距离、是否在区域内）
​    validated_nodes = validate_graph_with_postgis(graph_substructure, plan)

    # 3. 可选：在验证后的节点中再用 Milvus 做语义排序
​    final_candidates = apply_semantic_if_needed(
​        nodes=validated_nodes,
​        semantic_query=plan.semantic_query,
​        max_results=plan.max_results
​    )

    # 4. 压缩结果
​    compressed = compress_graph_results(final_candidates)

​    return {
​        "mode": "graph",
​        "anchor": plan.anchor.dict(),
​        "graph": compressed
​    }

------

### 4.3 阶段三：Writer（解释器）

**目标**：
只基于 Executor 的 JSON 输出 + 用户原始问题，生成自然语言回答。
**不再读取任何原始 POI 文档或全量数据**。

#### 4.3.1 Writer Prompt（System）

TEXT复制

你是一名空间数据与地理信息的解释专家。

你将收到一个 JSON，其中包括：
- 用户原始问题
- 查询计划（简要）
- 查询结果（候选 POI、类别统计、代表性地标、或图结构）

你的任务：
1. 仅根据 JSON 提供的信息生成自然语言回答；
2. 不要虚构地名、店名或数量（JSON 中没有的，不要编造）；
3. 如果 JSON 中包含 global_context 信息，可以简要描述该区域的业态结构；
4. 对于 basic 模式，重点列出与用户要求最匹配的若干 POI；
5. 对于 global_context 模式，可以兼顾“整体情况 + 代表性推荐”；
6. 对于 graph 模式，说明推荐路径或关系链条的“为什么”。

格式建议：
- 先简要回答核心问题；
- 然后按条目列出推荐对象及距离、评分等；
- 最后根据上下文可选给出补充说明或替代建议。

#### 4.3.2 WriterChain 实现示意

```
from langchain_core.prompts import ChatPromptTemplate from langchain_openai import ChatOpenAI WRITER_SYSTEM_PROMPT = """(如上所述)""" writer_prompt = ChatPromptTemplate.from_messages([    ("system", WRITER_SYSTEM_PROMPT),    ("human", "用户问题：{user_question}\n查询结果JSON：{result_json}") ]) llm_writer = ChatOpenAI(model_name="gpt-4o-mini", temperature=0.1) writer_chain = writer_prompt | llm_writer
```

------

## 5. 关键后端函数与 SQL 示例（供重构时参考）

> 以下内容用于指导 AIIDE 如何重写后端逻辑，避免在检索阶段调用 LLM。

### 5.1 锚点解析：地名 + 门 → 坐标

```
def resolve_anchor(anchor: Anchor) -> Dict[str, float]:    if anchor.type == "coordinate":        return {"lat": anchor.lat, "lon": anchor.lon}    elif anchor.type == "landmark":        # 1. 优先查 Landmark 表        gate_name = anchor.gate or ""        row = query_landmark_from_db(anchor.name, gate_name)        if row:            return {"lat": row["lat"], "lon": row["lon"]}        # 2. 回退到 Geocoder        geocoded = call_geocoder(anchor.name)        return {"lat": geocoded.lat, "lon": geocoded.lon}    else:        # 可扩展: area 等        raise NotImplementedError("Unknown anchor type")
```

### 5.2 PostGIS：附近 POI 查询

```
-- 示例函数：根据锚点和半径筛选候选 POI CREATE OR REPLACE FUNCTION search_pois_in_radius(    lon FLOAT, lat FLOAT,     radius_m FLOAT,    categories TEXT[],    min_rating FLOAT,    max_candidates INT ) RETURNS TABLE(    id INT,    name TEXT,    category TEXT,    rating FLOAT,    distance_m FLOAT ) AS $$ BEGIN    RETURN QUERY    WITH anchor AS (        SELECT ST_SetSRID(ST_MakePoint(lon, lat), 4326) AS g    )    SELECT         p.id,        p.name,        p.category,        p.rating,        ST_Distance(p.geom::geography, a.g::geography) AS distance_m    FROM pois p, anchor a    WHERE        p.category = ANY(categories)        AND p.rating >= min_rating        AND ST_DWithin(p.geom::geography, a.g::geography, radius_m)    ORDER BY distance_m    LIMIT max_candidates; END; $$ LANGUAGE plpgsql;
```

### 5.3 区域画像：类别统计

```
-- 示例：在给定 polygon 内按类别做统计 CREATE OR REPLACE FUNCTION category_stats_in_polygon(    poly GEOMETRY ) RETURNS TABLE(    category TEXT,    cnt BIGINT,    avg_rating FLOAT ) AS $$ BEGIN    RETURN QUERY    SELECT        p.category,        COUNT(*) AS cnt,        AVG(p.rating) AS avg_rating    FROM pois p    WHERE ST_Within(p.geom, poly)    GROUP BY p.category    ORDER BY cnt DESC; END; $$ LANGUAGE plpgsql;
```

### 5.4 Milvus：对候选集做语义排序（Python 伪代码）

```
def rank_by_semantic(semantic_query: str, candidate_ids: list[int], k: int):    if not candidate_ids:        return []     query_emb = embedding_model.encode(semantic_query)     # expr 中过滤候选 id    expr = f"id in {tuple(candidate_ids)}"    res = milvus_collection.search(        data=[query_emb],        anns_field="embedding",        param={"metric_type": "COSINE", "params": {"ef": 128}},        limit=k,        expr=expr,        output_fields=["id", "name", "category", "rating"]  # 可扩展    )    hits = res[0]    return [        {            "id": h.id,            "name": h.entity.get("name"),            "category": h.entity.get("category"),            "rating": h.entity.get("rating"),            "distance_m": None  # 如需距离，可从缓存中查回        }        for h in hits    ]
```

------

## 6. Token 控制与自主性增强策略

### 6.1 Token 控制硬规则

1. LLM 一次最多接收 10–30 条 POI
   - 其余统计在数据库做聚合，不逐条展示；
2. 所有空间计算在数据库执行
   - LLM 只看 `distance_m` 数值，不看原始经纬度；
3. 字段裁剪
   - 给 LLM 的 POI 结构仅包含：`name, category, rating, distance_m, anchor_name, tags`
   - address / geometry 如果非必须，不传或传简写版本；

### 6.2 提升自主性

1. 把“要不要区域画像、要不要图推理”等决策交给 Planner
   - 通过 `need_global_context` / `need_graph_reasoning` 等字段体现；
2. 加入澄清机制
   - 当 Planner 发现关键信息不足时，返回一种“需要澄清”的 Plan，由上层再问用户；
3. 可配置的执行策略
   - Executor 可以根据 Plan 中的字段动态选择：
     - 是否只用 PostGIS（纯结构）
     - 是否叠加 Milvus（语义偏好）
     - 是否调用图数据库（复杂关系）

------

## 7. 对现有代码的重构建议（给 AIIDE 的操作指引）

### 7.1 需要重构 / 替换的部分

1. **替换现有 `RetrievalQA` 链**
   - 由三段替代：
     - `PlannerChain`（LLM→QueryPlan）
     - `Executor`（Python+SQL，调用 PostGIS/Milvus/GraphDB）
     - `WriterChain`（LLM→最终自然语言）
2. **移除“全量 POI 文本拼接到 prompt”逻辑**
   - 所有向 LLM 提供的数据**必须源自 Executor 的压缩 JSON**。
3. **LangChain Loader 的职责限定为“离线向量化”**
   - 不再用于在线查询时读取文档并直接塞给 LLM。

### 7.2 可以保留 / 复用的部分

- PostGIS / Milvus / 图数据库的 schema 与索引设计；
- ETL 管道：PostgresLoader + DocumentTransformer + Embedding → Milvus；
- 现有的 Geocoder / Landmark 查询逻辑（只需接到 Executor 中）。

------

## 8. 典型请求的端到端示例（供实现校验）

### 8.1 示例问题

> “武理工南门对面500m内有哪些评分高于4.5分、环境安静适合自习的咖啡馆？”

### 8.2 三阶段流转

1. **Planner 输出的 Query Plan（示意）**

```
{  "anchor": {    "type": "landmark",    "name": "武汉理工大学",    "gate": "南门"  },  "radius_m": 500,  "categories": ["咖啡馆"],  "rating_range": [4.5, null],  "semantic_query": "环境安静 适合自习",  "need_global_context": true,  "need_graph_reasoning": false,  "summary_granularity": "detailed",  "max_results": 10 }
```

1. **Executor 返回的 JSON（示意）**

```
{  "mode": "global_context",  "anchor": {    "type": "landmark",    "name": "武汉理工大学",    "gate": "南门"  },  "pois": [    {      "id": 101,      "name": "星巴克咖啡",      "category": "咖啡馆",      "rating": 4.7,      "distance_m": 120,      "anchor_name": "武汉理工大学南门",      "tags": ["安静", "适合自习"]    },    {      "id": 102,      "name": "瑞幸咖啡",      "category": "咖啡馆",      "rating": 4.6,      "distance_m": 230,      "anchor_name": "武汉理工大学南门",      "tags": ["便捷", "外卖多"]    }  ],  "global_context": {    "category_stats": [      {"category": "餐饮", "cnt": 134, "avg_rating": 4.3},      {"category": "咖啡馆", "cnt": 5, "avg_rating": 4.5},      {"category": "蛋糕店", "cnt": 1, "avg_rating": 4.6}    ],    "landmarks": [      {"name": "青鱼嘴地铁站", "type": "地铁站", "distance_m": 300},      {"name": "实验小学", "type": "学校", "distance_m": 400}    ]  } }
```

1. **Writer 生成的回答（示意）**

> 武汉理工大学南门 500 米范围内，符合“环境安静、适合自习，评分高于 4.5 分”的咖啡馆主要有：
>
> 1. 星巴克咖啡（距离约 120 米，评分 4.7，环境安静，适合自习）；
> 2. 瑞幸咖啡（距离约 230 米，评分 4.6，座位相对紧凑，更适合短暂停留或外卖）。
>
> 从整体业态来看，该区域以内餐饮类设施为主（约 134 家），咖啡馆数量不多但评分整体较高。如果你希望有更多选择，可以考虑步行到青鱼嘴地铁站或实验小学附近，这两个地标周边也分布有一些适合学习和休息的店铺。

------

## 9. 小结（给 AIIDE 的实施要点）

1. **不要改动底层数据表结构**（PostGIS / Milvus / 图数据库保持不变）；

2. 重写上层调用逻辑为三阶段

   `PlannerChain → Executor → WriterChain`；

3. **所有 POI/空间计算尽量在数据库层完成**，LLM 绝不直接读大规模原始数据；

4. **对外只保留一个统一查询接口**，内部自动决定是否使用图推理 / 区域画像；

5. **实现时重点关注 Query Plan 结构、Executor 输出 JSON 结构、Writer 的 Prompt 约束**。

此 md 文档即为重构的“技术设计说明书”，可直接作为 AIIDE / 其他重构工具的输入依据。